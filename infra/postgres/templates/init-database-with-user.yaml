# =======================================
# Jesus, what the fuck is happening here?
# =======================================
#
# 1. Create a service account
# 2. Permit it to read configmaps and secrets in the faf-apps namespace
# 3. Iterate over the databasesAndUsers list and create a job for each database
#    a) initContainer: Load the configmap and secret into environment variables. This must happen via k8s api, as we can't directly reference cm/secrets cross-namespace.
#    b) actual container: Load the env from file and create the database and user

{{- $wave := 1 }}
{{- range .Values.databasesAndUsers }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: postgres-sync-db-user-{{ $wave }}
  labels:
    app: postgres-sync-db-user
    argocd.argoproj.io/instance: postgres
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: '{{ $wave }}'
spec:
  backoffLimit: 1
  template:
    spec:
      serviceAccountName: init-apps
      volumes:
        - name: config # We will store the apps config for database, username and password here
          emptyDir: {}
      initContainers:
        - name: load-config
          image: alpine/kubectl
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -e

              mkdir -p /config

              echo -n "SYNC_DATABASE=" > /config/env
              kubectl get cm {{ .configMapRef }} \
                -n faf-apps \
                -o jsonpath='{.data.{{ .databaseKey }}}' >> /config/env
              echo >> /config/env

              echo -n "SYNC_USERNAME=" >> /config/env
              kubectl get cm {{ .configMapRef }} \
                -n faf-apps \
                -o jsonpath='{.data.{{ .usernameKey }}}' >> /config/env
              echo >> /config/env

              echo -n "SYNC_PASSWORD=" >> /config/env
              kubectl get secret {{ .secretRef }} \
                -n faf-apps \
                -o jsonpath='{.data.{{ .passwordKey }}}' \
                | base64 -d >> /config/env
              echo >> /config/env
          volumeMounts:
            - name: config
              mountPath: /config
      containers:
        - name: postgres-sync-db-user
          image: {{ $.Values.image.repository }}:{{ $.Values.image.tag }}
          imagePullPolicy: Always
          envFrom:
            - secretRef:
                name: postgres
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -a
              . /config/env
              set +a

              export PGPASSWORD=${POSTGRES_PASSWORD}

              if psql --username=postgres --host=postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='${SYNC_USERNAME}'" | grep -q 1; then
                echo "User ${SYNC_USERNAME} already exists. Skipping user creation."
              else
                psql --username=postgres --host=postgres -c "CREATE USER \"${SYNC_USERNAME}\" WITH PASSWORD '${SYNC_PASSWORD}';"
                echo "User ${SYNC_USERNAME} created."
              fi

              if psql --username=postgres --host=postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${SYNC_DATABASE}'" | grep -q 1; then
                echo "Database ${SYNC_DATABASE} already exists. Skipping database creation."
              else
                psql --username=postgres --host=postgres -c "CREATE DATABASE \"${SYNC_DATABASE}\" OWNER \"${SYNC_USERNAME}\";"
                echo "Database ${SYNC_DATABASE} created."
              fi

              psql --username=postgres --host=postgres  -c "GRANT ALL PRIVILEGES ON DATABASE \"${SYNC_DATABASE}\" TO \"${SYNC_USERNAME}\";"
              echo "Granted all privileges on database ${SYNC_DATABASE} to user ${SYNC_USERNAME}."
          volumeMounts:
            - name: config
              mountPath: /config
      restartPolicy: Never
{{- $wave = add $wave 1 }}
{{- end }}
